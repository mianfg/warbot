#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
WarBotTwitter
=============

This module interacts with WarBotAPI to deliver messages to Twitter.

"""

__author__      = "Miguel √Ångel Fern√°ndez Guti√©rrez (@mianfg)"
__copyright__   = "Copyright 2019, Bloomgogo"
__credits__     = ["Miguel √Ångel Fern√°ndez Guti√©rrez"]
__license__     = "GPL"
__version__     = "1.0"
__mantainer__   = "Miguel √Ångel Fern√°ndez Guti√©rrez"
__email__       = "mianfg@bloomgogo.com"
__status__      = "Production"



from warbot import WarBot
from api import WarBotAPI
from database import WarBotDB
from imagehandler import WarBotImageHandler
from vars import log

import time, random, os
from datetime import datetime, timedelta


class WarBotTwitter:
    """
    Class used to deliver messages to and receive messages from Twitter

    ...

    Attributes
    ----------
    api : WarBotAPI
        Interact with Twitter API
    bot : WarBot
        Get and send information to bot
    sleep_time : int
        Sleep time for Twitter API
    sleep_time_optin : int
        Sleep time for Twitter API if opt-in activated
    imgh : WarBotImageHandler
        Generates images
    
    Methods
    -------

    """

    def __init__(self, consumer_key, consumer_secret, \
        access_token, access_token_secret, twitter_sleep_time, \
        database_route, database_filename, \
        phrases_route, phrases_filename, \
        ih_images_route, ih_resources_route, ih_store_route):
        """
        Parameters
        ----------
        consumer_key : str
            Twitter app consumer key
        consumer_secret : str
            Twitter app consumer secret
        access_token : str
            Twitter app access token
        access_token_secret : str
            Twitter app access token secret
        twitter_sleep_time : int
            Update time, in seconds
        database_route : str
            Folder route to database file
        database_filename : str
            Filename of JSON database for WarBotDB.
                To avoid bugs, must be absolute path
        phrases_route : str
            Folder route to phrases file
        phrases_filename : str
            Filename of txt file containing battle phrases
        ih_images_route : str
            Folder route to images for WarBotImageHandler.
                To avoid bugs, must be absolute path
        ih_resources_route : str
            Folder route to templates for WarBotImageHandler.
                To avoid bugs, must be absolute path
        ih_store_route : str
            Folder route to store images generated by WarBotImageHandler.
                To avoid bugs, must be absolute path
        """

        self.api = WarBotAPI(consumer_key, consumer_secret, \
            access_token, access_token_secret, \
            database_route, database_filename, ih_images_route)
        self.bot = WarBot(database_route, database_filename, \
            phrases_route, phrases_filename)
        self.sleep_time = twitter_sleep_time
        self.sleep_time_optin = twitter_sleep_time * 4
        self.imgh = WarBotImageHandler(ih_images_route, ih_resources_route, \
            ih_store_route)


    def battle(self):
        """Execute battle, as in /forcebattle

        Executes battle, randomly
        """

        winner, defeated = self.bot.battle()

        self.bot.add_battle_queue(winner, defeated)

        if self.bot.get_stop_frequency():
            self.bot.set_stop_next_battle(True)
        else:
            self.bot.set_stop_next_battle(False)

            newnextbattle = self.bot.get_next_battle()
            h, m = self.bot.get_battle_frequency()
            newnextbattle += timedelta(hours=h, minutes=m)

            self.bot.set_next_battle(newnextbattle)

     
    def optin(self):
        """Executes opt-in functionality
        """

        try:
            mentions = self.api.get_mentions()
            
            for mention in mentions:
                username = mention.user.screen_name
                self.bot.add_candidate(username)

            log.send_message("[TWITTER] Mentions caught")
        except Exception as e:
            log.send_message("[TWITTER] Mentions could not be caught -> " + str(e))


    def send_battle(self, winner, defeated, alivelist):
        """Send battle message to Twitter

        Sends battle message, including images

        Parameters
        ----------
        winner : str
            Winner fighter's username
        defeated : str
            Defeated fighter's username
        alivelist : list<str>
            Alive fighters' list
        """

        # generate filenames
        img1 = winner + "_profilepic.png"
        img1_route = self.api.download_profilepic(winner, img1)
        img2 = defeated + "_profilepic.png"
        img2_route = self.api.download_profilepic(defeated, img2)
        out = "battle-"+winner+"_"+defeated+".png"
        out_route = self.imgh.generate_battle(img1, img2, out)

        # generate text
        left = len(self.bot.get_alive_fighters())
        if left == 1:
            left_text = "¬°@{} has won the war! üèÜ".format(winner)
        else:
            left_text = "{} fighters left".format(left)
        if left == 2:
            left_text += ". Who will win the war? ü§î Do your bets!"
        images = [out_route]

        # if wants to display list
        if alivelist and left > 1:
            out2 = "alivefighters_" + str(random.randint(1000, 9999)) + ".png"
            out2_route = self.imgh.generate_alive(self.bot.get_fighters_extended(), out2)
            images.append(out2_route)
        if left == 1:
            out2 = "winnerfighter_" + str(random.randint(1000, 9999)) + ".png"
            out2_route = self.imgh.generate_winner(img1, out2)
            images.append(out2_route)
        
        # post tweet
        try:
            self.api.post_tweet(self.bot.generate_battle_text(winner, defeated) \
                + " " + left_text, images)
            log.send_message("[TWITTER] Tweet posted: " + winner + \
                " killed " + defeated)
            self.bot.add_message_queue("üõéÔ∏è Tweet posted: " \
                + "*{}* has killed *{}*.".format(winner, defeated))
        except Exception as e:
            log.send_message("[TWITTER] Tweet COULD NOT be posted: " + \
                winner + " killed " + defeated + " -> " + str(e))
            self.bot.add_message_queue("‚ö†Ô∏è Tweet could not be posted: " \
                + "*{}* has killed *{}*.".format(winner, defeated))

        # remove images generated
        os.remove(img1_route)
        os.remove(img2_route)
        os.remove(out_route)

        # generate list of 100 left, and save it
        if len(self.bot.get_alive_fighters()) == 100:
            self.imgh.generate_alive(self.bot.get_alive_fighters(), "alive_last100.png")

        if alivelist:
           os.remove(out2_route)
            

    def send_newfighter(self, username):
        """Send new fighter message to Twitter

        Sends new fighter message, including image
        """

        # generate filenames
        img = username + "_profilepic.png"
        img_route = self.api.download_profilepic(username, img)
        out = "newfighter-"+username+".png"
        out_route = self.imgh.generate_newfighter(img, out)

        # post tweet
        try:
            self.api.post_tweet("We have a new fighter! " + \
                "@{}, welcome to the battle!".format(username), [out_route])
            log.send_message("[TWITTER] Tweet posted: new fighter " + username)
            self.bot.add_message_queue("üõéÔ∏è Tweet posted: new fighter " \
                + "*{}*".format(username))
        except Exception as e:
            log.send_message("[TWITTER] Tweet COULD NOT be posted: new fighter " \
                + username + " -> " + str(e))
            self.bot.add_message_queue("‚ö†Ô∏è Tweet could not be posted: new " \
                + "fighter *{}*".format(username))

        # remove images generated
        os.remove(img_route)
        os.remove(out_route)


    def main(self):
        """Main function

        Main function to be executed
        """

        while True:
            ann_queue = self.bot.get_announce_queue()
            ann_queue = list(dict.fromkeys(ann_queue)) # for security
            self.bot.wipe_announce_queue()

            battle_queue = self.bot.get_battle_queue()
            self.bot.wipe_battle_queue()

            for fighter in ann_queue:
                if self.bot.get_fighter_announce():
                    self.send_newfighter(fighter)
            
            for battle in battle_queue:
                show_list = len(self.bot.get_alive_fighters()) \
                    < self.bot.show_threshold
                self.send_battle(battle['winner'], battle['defeated'], \
                    show_list)

            # battle scheduling
            if not self.bot.get_stop_next_battle():
                # run battle at specified time
                now = datetime.now().strftime("%d/%m/%Y %H:%M")
                
                sched = self.bot.get_next_battle().strftime("%d/%m/%Y %H:%M")
                
                if now == sched:
                    log.send_message("[TWITTER] Ran scheduled battle")
                    w, d = self.bot.battle()
                    if w == None or d == None:
                        self.bot.add_message_queue("‚ö†Ô∏è Scheduled battle could " \
                        + "not be executed. Stopping programmed battles.")
                        self.bot.set_stop_frequency(True)
                    else:
                        self.bot.add_message_queue("üõéÔ∏è A programmed battle " \
                            + "has been executed: *{}* ".format(w) \
                            + "has killed *{}*.".format(d))
                    self.bot.set_stop_next_battle(True)

                    # if the frequency is set, we set next schedule
                    if not self.bot.get_stop_frequency():
                        log.send_message("[TWITTER] New schedule set due " \
                            + "to schedule frequency")
                        # calculate next battle
                        h, m = self.bot.get_battle_frequency()
                        date = self.bot.get_next_battle() + \
                            timedelta(hours=int(h), minutes=int(m))
                        self.bot.set_next_battle(date.strftime("%d/%m/%Y %H:%M"))
                        self.bot.set_stop_next_battle(False)

            if self.bot.get_optin_running():
                self.optin()
                time.sleep(self.sleep_time_optin)
            else:
                time.sleep(self.sleep_time)